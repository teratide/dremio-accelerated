#pragma once

#include <cinttypes>
#include <cstring>
#include <ctime>
#include <memory>
#include <iostream>
#include <unistd.h>
#include <fcntl.h>
#include <fletcher/api.h>

/**
 * Namespace for the Tidre interface library.
 */
namespace tidre {

/**
 * Returns from the surrounding function when the status result of the given
 * command is not OK.
 */
#define TIDRE_CHECK_STATUS(x) do { auto _stat = x; if (!_stat.ok()) return _stat; } while (0)

/**
 * Shorthand for timestamps returned by time_get().
 */
using Timestamp = struct timespec;

/**
 * Returns the current timestamp.
 *
 * @return The current timestamp.
 */
static Timestamp GetTime() {
  Timestamp t;
  clock_gettime(CLOCK_MONOTONIC, &t);
  return t;
}

/**
 * Computes difference between two timestamps.
 *
 * @return The time spent in seconds.
 */
static double TimeDelta(const Timestamp &a, const Timestamp &b) {
  int64_t d = b.tv_sec - a.tv_sec;
  d *= 1000000000ll;
  d += b.tv_nsec;
  d -= a.tv_nsec;
  return ((double)d) * 1e-9;
}

/**
 * Wrapper class for kernels generated by Tidre.py in indices mode.
 *
 * @tparam NKERNEL The number of kernels that the platform was built with.
 */
template <size_t NKERNEL>
class Tidre {
 private:

  /**
   * Record batch start and end indices (end being exclusive). Set both to 0 to
   * gracefully disable a kernel. firstidx is also used as base offset for the
   * returned indices.
   */
  struct __attribute__((packed)) MmioIndex {
    uint32_t firstidx;
    uint32_t lastidx;
  };

  /**
   * String input buffer base pointers. The kernel starts reading the offset
   * buffer at offset + 4 * firstidx, so if firstidx is used to offset the output
   * indices, be sure to adjust it accordingly.
   */
  struct __attribute__((packed)) MmioStrBuf {
    uint64_t offset;
    uint64_t value;
  };

  /**
   * Index output buffer base pointer.
   */
  struct __attribute__((packed)) MmioIntBuf {
    uint64_t value;
  };

  /**
   * Result registers for number of regexes matched and number of UTF-8 decode
   * errors.
   */
  struct __attribute__((packed)) MmioResult {
    uint32_t nmatch;
    uint32_t nerror;
  };

  /**
   * Toplevel MMIO structure, placed at address 0 on BAR1.
   */
  struct __attribute__((packed)) Mmio {
    uint32_t ctrl; // ... reset stop start
    uint32_t stat; // ... done busy idle
    uint64_t PADDING; // result register, unused
    MmioIndex rb_in[NKERNEL];
    MmioIndex rb_out[NKERNEL];
    MmioStrBuf buf_in[NKERNEL];
    MmioIntBuf buf_out[NKERNEL];
    MmioResult result[NKERNEL];
  };

  /**
   * Fletcher platform to communicate with.
   */
  std::shared_ptr<fletcher::Platform> platform = {};

  /**
   * Number of kernels to use.
   */
  size_t numKernelsToUse = NKERNEL;

  /**
   * Number of beats for the upload/run/download pipeline.
   */
  size_t numPipelineBeats = 10;

  /**
   * DDR bank to use for even beats.
   */
  unsigned int ddrBankEven = 2;

  /**
   * DDR bank to use for odd beats.
   */
  unsigned int ddrBankOdd = 2;

  /**
   * Fill the given buffer with randomness by reading /dev/urandom into it.
   *
   * @param buf The buffer to write to.
   * @param size The amount of bytes to write.
   * @return Whether the operation was successful.
   */
  static fletcher::Status RandomizeBuffer(void *buf, size_t size) {
    int fd = open("/dev/urandom", O_RDONLY);
    if (fd < 0) return fletcher::Status::ERROR("Failed to open /dev/urandom");
    auto ptr = (uint8_t*)buf;
    while (size) {
      int amount = read(fd, ptr, size);
      if (amount <= 0) return fletcher::Status::ERROR("Failed to read from /dev/urandom");
      size -= amount;
      ptr += amount;
    }
    close(fd);
    return fletcher::Status::OK();
  }

  /**
   * Initialize Tidre.
   *
   * @param platform_name Name of the Fletcher platform to initialize, or empty
   * for auto-detection.
   * @return Whether initialization was successful.
   */
  fletcher::Status Init(
    const std::string &platformName
  ) {
    if (platformName.empty()) {
      TIDRE_CHECK_STATUS(fletcher::Platform::Make(&platform));
    } else {
      TIDRE_CHECK_STATUS(fletcher::Platform::Make(platformName, &platform));
    }
    TIDRE_CHECK_STATUS(platform->Init());
    return fletcher::Status::OK();
  }

  /**
   * Read the complete MMIO structure.
   *
   * @param mmio MMIO data will be returned here.
   * @return Whether the MMIO read was successful.
   */
  fletcher::Status ReadMMIO(Mmio *mmio) {
    if (!mmio) return fletcher::Status::ERROR("Return pointer is null");
    for (size_t i = 0; i < sizeof(Mmio)/4; i++) {
      TIDRE_CHECK_STATUS(platform->ReadMMIO(i, ((uint32_t*)mmio) + i));
    }
    return fletcher::Status::OK();
  }

  /**
   * Write all the input registers aside from the ctrl register in one go.
   *
   * @param mmio MMIO data will be read from here.
   * @return Whether the MMIO write was successful.
   */
  fletcher::Status WriteMMIO(const Mmio &mmio) {
    for (size_t i = 4; i < (sizeof(Mmio) - sizeof(MmioResult)*NKERNEL)/4; i++) {
      TIDRE_CHECK_STATUS(platform->WriteMMIO(i, ((const uint32_t*)&mmio)[i]));
    }
    return fletcher::Status::OK();
  }

  /**
   * Read the MMIO registers and dump them to stdout.
   *
   * @param verbose Whether to dump all registers or just the status register.
   * @return Whether the MMIO read was successful.
   */
  fletcher::Status DumpMMIO(bool verbose) {
    Mmio m;
    for (size_t i = 0; i < (verbose ? (sizeof(Mmio)/4) : 2); i++) {
      TIDRE_CHECK_STATUS(platform->ReadMMIO(i, ((uint32_t*)&m) + i));
    }
    std::cout << "stat " << m.stat << ", ctrl " << m.ctrl << " =";
    if (m.stat & 4) std::cout << " done";
    if (m.stat & 2) std::cout << " busy";
    if (m.stat & 1) std::cout << " idle";
    if (m.ctrl & 4) std::cout << " reset";
    if (m.ctrl & 2) std::cout << " stop";
    if (m.ctrl & 1) std::cout << " start";
    std::cout << std::endl;

    if (verbose) {
      for (size_t i = 0; i < NKERNEL; i++) {
        std::cout << "k" << i << ":" << std::endl;
        std::cout << "  input @ " << std::hex << m.buf_in[i].value << " (val)";
        std::cout << "and " << m.buf_in[i].offset << std::dec << " (offs), ";
        std::cout << "from " << m.rb_in[i].firstidx << " to " << m.rb_in[i].lastidx << std::endl;
        std::cout << "  output @ " << std::hex << m.buf_out[i].value << std::dec << ", ";
        std::cout << "from " << m.rb_out[i].firstidx << " to " << m.rb_out[i].lastidx << ", ";
        std::cout << "last wrote " << m.result[i].nmatch << std::endl;
        std::cout << "  " << m.result[i].nerror << " decode errors" << std::endl;
      }
    }
    return fletcher::Status::OK();
  }

  /**
   * Quickly start the kernel.
   *
   * @return Whether kernel start request was successfully sent.
   */
  fletcher::Status StartKernel() {
    TIDRE_CHECK_STATUS(platform->WriteMMIO(0, 4));
    TIDRE_CHECK_STATUS(platform->WriteMMIO(0, 1));
    return fletcher::Status::OK();
  }

  /**
   * Check whether the (previously started) kernel is done.
   *
   * @param out Result is returned here.
   * @return Whether kernel completion status was successfully read.
   */
  fletcher::Status IsKernelDone(bool *out) {
    if (!out) return fletcher::Status::ERROR("Return pointer is null");
    uint32_t val;
    TIDRE_CHECK_STATUS(platform->ReadMMIO(1, &val));
    *out = (val & 4u) != 0u;
    return fletcher::Status::OK();
  }

  /**
   * Busy-wait until the (previously started) kernel is done.
   *
   * @return Whether the kernel was successfully polled for completion.
   */
  fletcher::Status BusyWaitForKernel() {
    while (true) {
      bool val;
      TIDRE_CHECK_STATUS(IsKernelDone(&val));
      if (val) return fletcher::Status::OK();
    }
  }

  /**
   * Uploads a data buffer to the device.
   *
   * @param offset Device pointer (destination).
   * @param buf Host pointer (source).
   * @param size Number of bytes to copy.
   * @param verbose When set, print what we're doing.
   */
  fletcher::Status Upload(size_t offset, const void *buf, size_t size, bool verbose=false) {
    if (verbose) {
      std::cout << "  upload " << size << " bytes";
      std::cout << " from " << std::hex << (size_t)buf;
      std::cout << " to " << offset << std::dec << std::endl;
    }
    if (size) {
      TIDRE_CHECK_STATUS(platform->CopyHostToDevice((uint8_t*)buf, offset, size));
    }
    return fletcher::Status::OK();
  }

  /**
   * Downloads a data buffer from the device.
   *
   * @param offset Device pointer (source).
   * @param buf Host pointer (destination).
   * @param size Number of bytes to copy.
   * @param verbose When set, print what we're doing.
   */
  fletcher::Status Download(size_t offset, void *buf, size_t size, bool verbose=false) {
    if (verbose) {
      std::cout << "  download " << size << " bytes";
      std::cout << " from " << std::hex << offset;
      std::cout << " to " << (size_t)buf << std::dec << std::endl;
    }
    if (size) {
      TIDRE_CHECK_STATUS(platform->CopyDeviceToHost(offset, (uint8_t*)buf, size));
    }
    return fletcher::Status::OK();
  }

  /**
   * Internal kernel for TransferTest().
   *
   * @param offset Device base address to read/write.
   * @param buf1 Source host buffer, filled with randomness by this function.
   * @param buf2 Destination host buffer, as read back from the device.
   * @param size Amount of bytes to transfer.
   * @return Whether the transfers were successful.
   */
  fletcher::Status TransferTestKernel(size_t offset, uint8_t *buf1, uint8_t *buf2, size_t size) {
    Timestamp a = GetTime();
    TIDRE_CHECK_STATUS(RandomizeBuffer(buf2, size));
    Timestamp b = GetTime();
    TIDRE_CHECK_STATUS(Upload(offset, buf1, size));
    Timestamp c = GetTime();
    TIDRE_CHECK_STATUS(Download(offset, buf2, size));
    Timestamp d = GetTime();
    if (memcmp(buf1, buf2, size) == 0) return fletcher::Status::ERROR("Buffer mismatch");
    Timestamp e = GetTime();

    std::cout << "randomize: " << size/(TimeDelta(a, b)*1e6) << "MB/s" << std::endl;
    std::cout << "write: " << size/(TimeDelta(b, c)*1e6) << "MB/s" << std::endl;
    std::cout << "read: " << size/(TimeDelta(c, d)*1e6) << "MB/s" << std::endl;
    std::cout << "verify: " << size/(TimeDelta(d, e)*1e6) << "MB/s" << std::endl;

    return fletcher::Status::OK();
  }

  /**
   * Increments the given offset by the given size, then aligns to a 4kiB
   * boundary.
   */
  static size_t IncrementOffset(size_t offset, size_t size) {
    offset += size + 4095;
    offset &= ~4095ull;
    return offset;
  }

 public:

  /**
   * Constructor is no-op because we can't return errors there.
   */
  Tidre() = default;

  Tidre(const Tidre&) = delete;
  Tidre(Tidre&&) = delete;
  Tidre &operator=(const Tidre&) = delete;
  Tidre &operator=(Tidre&&) = delete;

  /**
   * Tweaks runtime parameters that might affect performance.
   *
   * @param newNumPipelineBeats Number of beats for the upload/run/download
   * pipeline.
   * @param newNumKernelsToUse Number of kernels to use for the computation.
   * @param newDdrBankEven The DDR bank (0..3) to use for even beats.
   * @param newDdrBankOdd The DDR bank (0..3) to use for odd beats.
   * @return Whether the parameters were set correctly.
   */
  fletcher::Status Tweak(
    size_t newNumPipelineBeats,
    size_t newNumKernelsToUse=NKERNEL,
    unsigned int newDdrBankEven=2,
    unsigned int newDdrBankOdd=2
  ) {
    if (newNumPipelineBeats == 0) return fletcher::Status::ERROR("Need to use at least one pipeline beat");
    if (newNumKernelsToUse == 0) return fletcher::Status::ERROR("Need to use at least one kernel");
    if (newNumKernelsToUse > NKERNEL) return fletcher::Status::ERROR("Too many kernels for design");
    if (newDdrBankEven > 3) return fletcher::Status::ERROR("Even DDR bank out of range");
    if (newDdrBankOdd > 3) return fletcher::Status::ERROR("Odd DDR bank out of range");
    numPipelineBeats = newNumPipelineBeats;
    numKernelsToUse = newNumKernelsToUse;
    ddrBankEven = newDdrBankEven;
    ddrBankOdd = newDdrBankOdd;
    return fletcher::Status::OK();
  }

  /**
   * Constructs a new Tidre instance.
   *
   * @param out The constructed Tidre instance.
   * @param platform_name Name of the Fletcher platform to initialize, or empty
   * for auto-detection.
   * @param numPipelineBeats Number of beats for the upload/run/download
   * pipeline.
   * @param numKernelsToUse Number of kernels to use for the computation.
   * @param ddrBankEven The DDR bank (0..3) to use for even beats.
   * @param ddrBankOdd The DDR bank (0..3) to use for odd beats.
   */
  static fletcher::Status Make(
    std::shared_ptr<Tidre> *out,
    const std::string &platformName="",
    size_t numPipelineBeats=10,
    size_t numKernelsToUse=NKERNEL,
    unsigned int ddrBankEven=2,
    unsigned int ddrBankOdd=2
  ) {
    if (!out) return fletcher::Status::ERROR("Return pointer is null");
    auto tidre = std::make_shared<Tidre>();
    TIDRE_CHECK_STATUS(tidre->Init(platformName));
    TIDRE_CHECK_STATUS(tidre->Tweak(numPipelineBeats, numKernelsToUse, ddrBankEven, ddrBankOdd));
    *out = tidre;
    return fletcher::Status::OK();
  }

  /**
   * Runs the regex matching kernel on the raw buffers.
   *
   * @param in_offs Pointer to the offset buffer. Must be 4*(in_nrows+1) in
   * size.
   * @param in_data Pointer to the values buffer. Must be in_offs[in_nrows] in
   * size.
   * @param in_nrows Number of rows in the input batch.
   * @param out_ptr Output buffer that will receive 4-byte indices.
   * @param out_size Size of the output buffer in bytes. If it's too small,
   * data will be missing, but this function will not write out of bounds.
   * @param nmatch If non-null, will receive the total number of matches.
   * @param nerror If non-null, will receive the total number of UTF-8 decode
   * errors.
   * @param verbose When nonzero, statistics will be printed.
   *
   * @return Zero on success, nonzero on failure.
   */
  fletcher::Status RunRaw(
    const void *in_offs,
    const void *in_data,
    size_t in_nrows,
    void *out_ptr,
    size_t out_size,
    size_t *nmatch,
    size_t *nerror,
    int verbose
  ) {
    auto *offs_buf = (const uint32_t*)in_offs;
    auto *data_buf = (const uint8_t*)in_data;
    auto *out_buf = (uint8_t*)out_ptr;

    // Ensure that we can read MMIO.
    uint32_t status = 0xDEADBEEF;
    TIDRE_CHECK_STATUS(platform->ReadMMIO(1, &status));
    if (verbose) std::cout << "initial kernel status: " << status << std::endl;

    // Where the device memory for the odd kernel runs is based. Depends on
    // number of DDR banks!
    static const size_t EVEN_OFFSET = 0x400000000ull*ddrBankEven;
    static const size_t ODD_OFFSET  = 0x400000000ull*ddrBankOdd;

    // Output accumulators.
    size_t nmatch_accum = 0;
    size_t nerror_accum = 0;

    // Amount of time spent waiting for the kernels.
    double kernel_wait_time = 0.0;

    // MMIO shadow buffers.
    Mmio m_even, m_odd;
    memset(&m_even, 0, sizeof(Mmio));
    memset(&m_odd, 0, sizeof(Mmio));

    for (size_t beat = 0; beat <= numPipelineBeats; beat++) {
      bool odd_cur = (beat & 1u) == 1u;
      bool odd_next = !odd_cur;
      Mmio *m_cur = odd_cur ? &m_odd : &m_even;
      Mmio *m_next = odd_next ? &m_odd : &m_even;

      // Preparation for next beat.
      if (beat < numPipelineBeats) {
        if (verbose) std::cout << "upld beat " << beat+1 << std::endl;

        // Compute overall start and end.
        size_t start = (in_nrows * beat) / numPipelineBeats;
        size_t end = (in_nrows * (beat + 1)) / numPipelineBeats;
        if (verbose) std::cout << "  start " << start << ", end " << end << std::endl;

        // Offset to start allocating device buffers at.
        size_t offset = odd_next ? ODD_OFFSET : EVEN_OFFSET;

        // Upload offset buffer for next beat.
        size_t      offs_full_offs = offset;
        size_t      offs_full_size = (in_nrows * 4) + 1;
        const void *offs_part_src  = offs_buf + start;
        size_t      offs_part_offs = offs_full_offs + start * 4;
        size_t      offs_part_size = (end - start + 1) * 4;
        size_t      offs_misalign  = offs_part_offs & 63;
        TIDRE_CHECK_STATUS(Upload(
          offs_part_offs - offs_misalign,
          ((const uint8_t*)offs_part_src) - offs_misalign,
          offs_part_size + offs_misalign,
          verbose
        ));
        offset = IncrementOffset(offset, offs_full_size);

        // Upload data buffer for next beat.
        size_t      data_full_offs = offset;
        size_t      data_full_size = offs_buf[in_nrows] - offs_buf[0];
        const void *data_part_src  = data_buf + offs_buf[start];
        size_t      data_part_offs = data_full_offs + offs_buf[start];
        size_t      data_part_size = offs_buf[end] - offs_buf[start];
        size_t      data_misalign  = data_part_offs & 63;
        TIDRE_CHECK_STATUS(Upload(
          data_part_offs - data_misalign,
          ((const uint8_t*)data_part_src) - data_misalign,
          data_part_size + data_misalign,
          verbose
        ));
        offset = IncrementOffset(offset, data_full_size);

        // Compute MMIO config for next beat.
        for (size_t k = 0; k < numKernelsToUse; k++) {
          end = (in_nrows * (beat * numKernelsToUse + k + 1)) / (numPipelineBeats * numKernelsToUse);
          m_next->buf_in[k].offset = offs_full_offs;
          m_next->buf_in[k].value = data_full_offs;
          m_next->rb_in[k].firstidx = start;
          m_next->rb_in[k].lastidx = end;
          m_next->buf_out[k].value = offset;
          offset = IncrementOffset(offset, (end - start + 1) * 4);
          start = end;
        }

      }

      // Wait for current beat to complete.
      if (beat > 0) {
        if (verbose) std::cout << "wait beat " << beat << std::endl;

        // Wait for current beat.
        Timestamp t1 = GetTime();
        TIDRE_CHECK_STATUS(BusyWaitForKernel());
        Timestamp t2 = GetTime();
        kernel_wait_time += TimeDelta(t1, t2);

        // Read back MMIO from current beat.
        if (verbose > 1) TIDRE_CHECK_STATUS(DumpMMIO(true));
        TIDRE_CHECK_STATUS(ReadMMIO(m_cur));

      }

      // Start the next beat.
      if (beat < numPipelineBeats) {
        if (verbose) std::cout << "strt beat " << beat+1 << std::endl;

        // Configure kernel.
        TIDRE_CHECK_STATUS(WriteMMIO(*m_next));
        if (verbose > 1) TIDRE_CHECK_STATUS(DumpMMIO(true));

        // Start execution.
        TIDRE_CHECK_STATUS(StartKernel());

      }

      // Handle the results from the current beat.
      if (beat > 0) {
        if (verbose) std::cout << "down beat " << beat << std::endl;
        for (size_t k = 0; k < numKernelsToUse; k++) {

          // Accumulate counters.
          nmatch_accum += m_cur->result[k].nmatch;
          nerror_accum += m_cur->result[k].nerror;

          // Pull index output data if there is still room in the buffer.
          if (out_size) {
            size_t size = m_cur->result[k].nmatch * 4;
            TIDRE_CHECK_STATUS(Download(m_cur->buf_out[k].value, out_buf, size));
            out_size -= size;
            out_buf += size;
          }

        }
      }

    }

    if (verbose) std::cout << "kernel wait time: " << kernel_wait_time << "s" << std::endl;

    // Write output.
    if (nmatch) *nmatch = nmatch_accum;
    if (nerror) *nerror = nerror_accum;

    return fletcher::Status::OK();
  }

  /**
   * Run the kernel with test data.
   *
   * @param num_records Number of strings to generate.
   * @param str_size String length (this is not random).
   * @param match_str The string used for generating matching records.
   * @param match_period Every Nth string will be designed to match (phase is
   * such that the first record always matches).
   * @param verbose Verbosity level for the run.
   * @return Whether the run was successful.
   */
  fletcher::Status KernelTest(
    size_t num_records,
    size_t str_size,
    const std::string &match_str,
    size_t match_period,
    int verbose
  ) {

    std::cout << "Generating data; expected match count = " << (num_records + match_period - 1) / match_period << std::endl;

    // Construct offset buffer.
    size_t offs_size = (num_records + 1) * 4;
    uint32_t *offs_buf;
    posix_memalign((void**)&offs_buf, 64, offs_size);
    if (!offs_buf) return fletcher::Status::ERROR("Failed to allocate offset buffer");
    for (uint32_t i = 0; i < num_records+1; i++) {
      offs_buf[i] = i * str_size;
    }

    // Construct data buffer.
    size_t data_size = num_records * str_size;
    uint8_t *data_buf;
    posix_memalign((void**)&data_buf, 64, data_size);
    if (!data_buf) return fletcher::Status::ERROR("Failed to allocate data buffer");
    memset(data_buf, ' ', data_size);
    if (str_size >= match_str.size()) {
      for (size_t i = 0; i < num_records; i += match_period) {
        memcpy(data_buf + (i * str_size), match_str.data(), match_str.size());
      }
    }

    // Construct result buffer.
    size_t result_size = num_records * 4;
    auto result_buf = (uint32_t*)malloc(result_size);

    // Run the kernel.
    std::cout << "Running kernel..." << std::endl;
    size_t nmatch, nerror;
    Timestamp t1 = GetTime();
    TIDRE_CHECK_STATUS(RunRaw(offs_buf, data_buf, num_records, result_buf, result_size, &nmatch, &nerror, verbose));
    Timestamp t2 = GetTime();
    std::cout << nmatch << " matches, " << nerror << " decode errors" << std::endl;
    std::cout << "indices:";
    if (nmatch > 32) {
      for (size_t i = 0; i < 16; i++) {
        std::cout << " " << result_buf[i];
      }
      std::cout << " ...";
      for (size_t i = nmatch - 16; i < nmatch; i++) {
        std::cout << " " << result_buf[i];
      }
    } else {
      for (size_t i = 0; i < nmatch; i++) {
        std::cout << " " << result_buf[i];
      }
    }
    std::cout << std::endl;

    free(offs_buf);
    free(data_buf);
    free(result_buf);

    std::cout << "time spent: " << TimeDelta(t1, t2) << std::endl;

    return fletcher::Status::OK();
  }

  /**
   * Check whether a burst write-read transaction of the given size works right
   * at the given offset. Records and prints the transfer speeds to stdout.
   *
   * @param offset Device base address to read/write.
   * @param size Amount of bytes to transfer.
   * @param align Alignment requirement for host buffer allocation.
   * @param misalign Intentional misalignment of the host buffer pointers
   * w.r.t. the above to test the performance impact of misalignment.
   * @return Whether the transfers were successful.
   */
  fletcher::Status TransferTest(size_t offset, size_t size, size_t align=4096, size_t misalign=0) {
    uint8_t *buf1;
    posix_memalign((void**)&buf1, align, size + misalign);
    if (!buf1) return fletcher::Status::ERROR("Failed to allocate memory");
    uint8_t *buf2;
    posix_memalign((void**)&buf2, align, size + misalign);
    if (!buf2) return fletcher::Status::ERROR("Failed to allocate memory");

    auto status = TransferTestKernel(offset, buf1 + misalign, buf2 + misalign, size);

    free(buf1);
    free(buf2);
    return status;
  }

};

} // namespace tidre
